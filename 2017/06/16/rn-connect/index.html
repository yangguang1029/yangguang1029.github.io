<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    Redux中的Provider和connect 丨
    

    typo
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">杨光的日记本</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">Redux中的Provider和connect</div>
  <div class="post-meta">
    <div class="date">2017 June 16th</div>
    <div class="tags">
      
      <div class="tag-item">ReactNative</div>
      
    </div>
  </div>
  

  <main class="post-content"><p>redux里有不少概念，一时半会看不明白，这里讲下我理解的provider和connect。我们知道使用Reudx，数据作为state被存储在一个单独的store中。我们在渲染时从state获取数据，需要修改数据时，dispatch一个action即可。provider和connect的作用，是为了更方便的存取state数据。</p>
<p>如果不使用provider和connect，也是完全没问题的，这样的话我们需要把store传入到Component中以便使用，例如需要这么写：</p>
<pre><code>index.android.js:	//此代码缺少action和reducer的实现，并不能直接运行，只是用以描述

let store = createStore(reducer);
export default class testrn extends Component&#123;
    render()&#123;
        &lt;NoConnect store=&#123;store&#125;/&gt;
    &#125;
&#125;

NoConnect.js:

export default class NoConnect extends Component&#123;
    constructor(props)&#123;
        super(props);
        this.state = this.props.store.getState();
    &#125;
    render()&#123;
        return (&lt;View&gt;
            &lt;Text&gt;this.state.prop1&lt;/Text&gt;
            &lt;Button title=&quot;click&quot; onPress=&#123;()=&gt;&#123;
                this.props.store.dispatch(action);
                this.setState(this.props.store.getState());
            &#125;&#125;&gt;
        &lt;/View&gt;)
    &#125;
&#125;
</code></pre>
<p>从上面可以看出来，我们主要是通过把store传入Component，然后利用它的getState和dispatch接口进行存取数据，数据需要保存为自身的state，在dispatch后需要通过setState来刷新界面。</p>
<p>如果使用provider和connect，就可以大大简化代码了。例如</p>
<pre><code>index.android.js:

let store = createStore(reducer);
export default class testrn extends Component&#123;
    render()&#123;
        &lt;Provider store=&#123;store&#125;&gt;
        &lt;TestContainer  /&gt;
        &lt;/Provider&gt;
    &#125;
&#125;

testContainer.js:
import &#123; connect &#125; from &#39;react-redux&#39;;
class testContainer extends Component&#123;
    render()&#123;
        return (&lt;View&gt;
            &lt;Text&gt;this.props.text1&lt;/Text&gt;
            &lt;Button title=&quot;click&quot; onPress=&#123;()=&gt;&#123;
                this.props.change1(&quot;123&quot;);
            &#125;&#125;&gt;
        &lt;/View&gt;)
    &#125;
&#125;

const mapStateToProps = (state, ownProps)=&gt;&#123;
    return &#123;
        text1:state.prop1
    &#125;
&#125;

const mapDispatchToProps = &#123;
    change1:Actions.createAction1
&#125;

export default connect(mapStateToProps, mapDispatchToProps)(testContainer)
</code></pre>
<p>从上面代码可以看出来，在Component里不再需要使用store变量，代码简化了。只要被Provider包含着的组件及其子组件，都可以使用connect方法，就不需要到处传递store变量了。</p>
<p>mapStateToProps的作用，就是把state内的值转换成Component的props的值，这样在Component内使用时，不需要通过store.getState来获取并存为自己的state了。每当state发生变化时，这个方法就会被调用，这样Component的props就被修改了，于是就不用再通过setState来通知页面刷新。</p>
<p>mapStateToProps是一个方法，它的第一个参数就是state，第二个参数ownProps是传递给Component的props。在上述代码中就是<code>&lt;TestContainer /&gt;</code>处传递的props</p>
<p>mapDispatchToProps的作用，就是把创建action的方法，绑定在Component的props上，这样就不需要通过store.dispatch来更改state。</p>
<p>上述代码中mapDispatchToProps是一个Object，它的values就是创建action的方法，keys绑定为Component的props属性，这样在testContainer中调用this.props.change1就创建并发布了一个action。</p>
<p>mapDispatchToProps也可以是一个方法，它的第一个参数是store的dispatch方法，第二个参数是ownProps。用方法实现比起用Object实现，可以做更多的注入操作，代码如下</p>
<pre><code>const mapDispatchToProps = (dispatch, ownProps) &#123;
    return &#123;
        change1:(data)=&gt;&#123;
            console.log(&quot;dispatch action1.....&quot;);
            dispatch(Actions.createAction1(data));
        &#125;
    &#125;
&#125;
</code></pre>
<p>可以看到如果用方法来实现，在change1里就可以做很灵活的操作了。同时Redux提供了一个很简便的接口bindActionCreators(Actions, dispatch)，使用它相当于使用Object实现，并且key和创建action的方法名一致。</p>
<p>上面代码里用到的Actions，是创建action的接口</p>
<p>除了上面提到的mapStateToProps和mapDispatchToProps外，connect方法后面还可以再带两个参数</p>
<p>mergeprops</p>
<p>options:</p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2024 typo</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>