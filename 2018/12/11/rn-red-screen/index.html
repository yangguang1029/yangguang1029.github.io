<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    ReactNative之红屏是如何产生的 丨
    

    typo
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">杨光的日记本</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">ReactNative之红屏是如何产生的</div>
  <div class="post-meta">
    <div class="date">2018 December 11th</div>
    <div class="tags">
      
      <div class="tag-item">ReactNative</div>
      
    </div>
  </div>
  

  <main class="post-content"><p>我们在开发RN项目时，红屏是司空见惯的事情，然后我发现很多人会问，调试时出现红屏，那应用发布后是否会红屏呢？要确定的知道答案，还得从源代码去看。</p>
<p>在node_modules&#x2F;react-native&#x2F;Libraries&#x2F;Core&#x2F;InitializeCore.js中有一段代码</p>
<pre><code>const handleError = (e, isFatal) =&gt; &#123;
  try &#123;
    ExceptionsManager.handleException(e, isFatal);
  &#125; catch (ee) &#123;
    console.log(&#39;Failed to print error: &#39;, ee.message);
    throw e;
  &#125;
&#125;;
const ErrorUtils = require(&#39;ErrorUtils&#39;);
ErrorUtils.setGlobalHandler(handleError);
</code></pre>
<p>这是默认的异常处理函数。handleException的实现，在node_modules&#x2F;react-native&#x2F;Libraries&#x2F;Core&#x2F;ExceptionsManager.js中</p>
<pre><code>const &#123;ExceptionsManager&#125; = require(&#39;NativeModules&#39;);
ExceptionsManager.reportFatalException
ExceptionsManager.reportSoftException
</code></pre>
<p>然后就进入到了原生代码中。</p>
<p>先看iOS中的RCTExceptionManager.m中的reportFatalException函数可以看到</p>
<pre><code>[_bridge.redBox showErrorMessage:message withStack:stack];
if (_delegate) &#123;
  [_delegate handleFatalJSExceptionWithMessage:message stack:stack exceptionId:exceptionId];
&#125;
static NSUInteger reloadRetries = 0;
if (!RCT_DEBUG &amp;&amp; reloadRetries &lt; _maxReloadAttempts) &#123;
  reloadRetries++;
  [_bridge reload];
&#125; else &#123;
  NSString *description = [@&quot;Unhandled JS Exception: &quot; stringByAppendingString:message];
  NSDictionary *errorInfo = @&#123; NSLocalizedDescriptionKey: description, RCTJSStackTraceKey: stack &#125;;
  RCTFatal([NSError errorWithDomain:RCTErrorDomain code:0 userInfo:errorInfo]);
&#125;
</code></pre>
<p>这就是产生红屏的代码，可以看到，只要异常进入到原生层，都会出现红屏，不论是连本地webserver调试，还是加载包内或文件夹内bundle，更和打bundle时是否是dev模式无关。然后可以看到这里允许使用delegate在收到错误时进行额外处理，例如进行上报。如果是release模式且设置了maxReloadAttempts值（默认为0），就会进行reload重试，再进去RCTFatal函数可以看到它的实现是抛出了一个异常，但debug模式下会try catch住，避免应用崩溃，而release模式下则不会try catch，异常会继续抛出。</p>
<p>android端要复杂一些，首先仍然是找到ExceptionManagerModule.java，它里面的实现是</p>
<pre><code>if (mDevSupportManager.getDevSupportEnabled()) &#123;
  mDevSupportManager.showNewJSError(title, details, exceptionId);
&#125; else &#123;
  throw new JavascriptException(JSStackTrace.format(title, details));
&#125;
</code></pre>
<p>如果mDevSupportManager.getDevSupportEnabled返回true，那么就会调用showNewJSError处理，否则直接抛出异常，这会导致应用直接闪退。mDevSupportManager的来源是ReactInstanceManager的构造函数，通过源代码可以看到如果useDeveloperSupport为false,则使用的是DisabledDevSupportManager，否则是DevSupportManagerImpl。useDeveloperSupport又来自于ReactNativeHost的接口getUseDeveloperSupport，模板工程里它的实现是</p>
<pre><code>public boolean getUseDeveloperSupport() &#123;
  return BuildConfig.DEBUG;
&#125;
</code></pre>
<p>所以对android端来说，release模式使用的DisabledDevSupportManager的getDevSupportEnabled返回false，所以在接到js层传来的异常时会直接抛出一个java异常，然后就结束了。debug模式使用的DevSupportManagerImpl，它的getDevSupportEnabled由ReactInstanceManager调用setDevSupportEnabled进行控制，它的showNewError就是产生红屏的具体实现代码。</p>
<p>根据上面的一路跟踪，我们可以得出的结论是：</p>
<ol>
<li>如果不想出现红屏，最方便的办法就是在js层使用ErrorUtils.setGlobalHandler捕获异常，这样异常不会被传到原生层，也就不会导致红屏了</li>
<li>如果异常被传到原生层，iOS端一定会出现红屏，release模式下可能闪退。Android端在release模式下不会红屏但可能会闪退，debug模式下则会红屏</li>
</ol>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2024 typo</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>