<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    

    typo
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">杨光的日记本</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <div class="post-list">
  
  <section class="post-item">
    <a class="post-item-title" href="/2018/06/14/oc-metaclass/">ObjectiveC之初解MetaClass</a>
    <div class="post-item-summary">
      MetaClass的概念是每一个进阶iOS开发者都需要了解的概念，因为有的地方看得不是很容易理解，所以配合例子介绍一下概念。
在ObjectiveC中，每个类都对应着一个对象，我们把它叫做类对象，它其实是一个结构体struct objc_class。当这个类构造出一个实例后，实例的isa指针就指向了这个类对象。而类对象本身也有一个isa指针，它指向了这个类的元类MetaClass。元类也是一个struct objc_class，它也有一个isa指针，指向了NSObject的M
      <a class="read-more" href="/2018/06/14/oc-metaclass/"> ... </a>
    </div>
    <div class="post-item-extra">
      <div class="date">2018.06.14</div>
      <div class="tags">
        
        <div class="tag-item">ObjectiveC</div>
        
      </div>
    </div>
  </section>
  
  <section class="post-item">
    <a class="post-item-title" href="/2018/05/28/rn-event-emitter/">ReactNative之EventEmitter</a>
    <div class="post-item-summary">
      官方文档推荐的原生往js层传递消息的方式，iOS端是继承RCTEventEmitter，然后调用sendEventWithName方法
[self sendEventWithName:@&quot;EventReminder&quot; body:nil];

Android端是
getReactApplicationContext()
            .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitte
      <a class="read-more" href="/2018/05/28/rn-event-emitter/"> ... </a>
    </div>
    <div class="post-item-extra">
      <div class="date">2018.05.28</div>
      <div class="tags">
        
        <div class="tag-item">ReactNative</div>
        
      </div>
    </div>
  </section>
  
  <section class="post-item">
    <a class="post-item-title" href="/2018/05/23/rn-native-call-js/">ReactNative之快速实现native调用js</a>
    <div class="post-item-summary">
      在官方文档里推荐的原生调用js的方法是通过发送事件，也就是通过DeviceEventEmitter来发送事件，然后在js层监听。这样虽然可以实现，但毕竟感觉有点绕弯，实际上观察一下源代码就会发现原生层有直接调用js的接口。它们分别是：
iOS端位于RCTBridge中
- (void)enqueueJSCall:(NSString *)module method:(NSString *)method args:(NSArray *)args completion:(dispa
      <a class="read-more" href="/2018/05/23/rn-native-call-js/"> ... </a>
    </div>
    <div class="post-item-extra">
      <div class="date">2018.05.23</div>
      <div class="tags">
        
        <div class="tag-item">ReactNative</div>
        
      </div>
    </div>
  </section>
  
  <section class="post-item">
    <a class="post-item-title" href="/2018/05/22/rn-tableview/">ReactNative之封装TableView组件</a>
    <div class="post-item-summary">
      众所周知，ReactNative中的列表组件，不论是老版的ListView还是新版的FlatList，都不是对原生列表的封装，只是在JavaScript层在ScrollView的基础上实现的，如果能基于原生列表组件进行封装，就真正实现了单元行的复用，最近尝试了下对iOS平台tableView的封装，demo已经运行正常了，这里把思路整理一下。
封装tableView本身很简单，按官方教程走就行了。我们从js中传一个rowCount属性过来，用于给tableView的numbe
      <a class="read-more" href="/2018/05/22/rn-tableview/"> ... </a>
    </div>
    <div class="post-item-extra">
      <div class="date">2018.05.22</div>
      <div class="tags">
        
        <div class="tag-item">ReactNative</div>
        
      </div>
    </div>
  </section>
  
  <section class="post-item">
    <a class="post-item-title" href="/2018/04/04/rn-import-require/">ReactNative之两种模块管理方式</a>
    <div class="post-item-summary">
      在RN项目的js代码中，是可以使用两种模块管理方式的，分别是ES6风格和CommonJS风格，代码示例如
//ES6风格
//a.js
export let a = 1;
export function adda()&#123;
    a += 1;
&#125;
//index.js
import &#123;a, adda&#125; from &quot;./a.js&quot;
console.log(&quot;a is &quot; + a)
adda();
c
      <a class="read-more" href="/2018/04/04/rn-import-require/"> ... </a>
    </div>
    <div class="post-item-extra">
      <div class="date">2018.04.04</div>
      <div class="tags">
        
        <div class="tag-item">ReactNative</div>
        
      </div>
    </div>
  </section>
  
  <section class="post-item">
    <a class="post-item-title" href="/2018/03/12/rn-cached-view/">ReactNative之一个组件缓存的方案</a>
    <div class="post-item-summary">
      在实际开发中，我们经常会有这样的场景，一个组件需要根据条件来决定显示还是隐藏，我们一般都不假思索就可以写出这种方案
this.state.isVisible ? &lt;MyComponent /&gt; : null

一般来说这样做都没什么问题，但假如这个MyComponent非常庞大，而显示隐藏又很频繁，这样做性能就很低，根据前面的一篇博文《ReactNative之VirtualDomTree的diff原理》，实际上我们把一个组件在不同的类型MyComponent和nu
      <a class="read-more" href="/2018/03/12/rn-cached-view/"> ... </a>
    </div>
    <div class="post-item-extra">
      <div class="date">2018.03.12</div>
      <div class="tags">
        
        <div class="tag-item">ReactNative</div>
        
      </div>
    </div>
  </section>
  
  <section class="post-item">
    <a class="post-item-title" href="/2018/03/07/js-const-var/">javaScript之let和var在闭包内的区别</a>
    <div class="post-item-summary">
      今天在解决一个bug时碰到的问题，经过层层抽象后，最终通过demo来测试，代码如下
var functions = [];
let str = `
    var a = [1,2,3];
    functions.push(()=&gt;&#123;
        console.log(JSON.stringify(a))
    &#125;)
`;
eval(str);
let str1 = `
    var a = [4,5,6];
    functions
      <a class="read-more" href="/2018/03/07/js-const-var/"> ... </a>
    </div>
    <div class="post-item-extra">
      <div class="date">2018.03.07</div>
      <div class="tags">
        
        <div class="tag-item">javascript</div>
        
      </div>
    </div>
  </section>
  
  <section class="post-item">
    <a class="post-item-title" href="/2018/02/28/rn-props-children/">ReactNative之props.children</a>
    <div class="post-item-summary">
      在github上看react-native-on-layout的实现代码时，发现它把this.props.children当成一个函数使用，当时就奇怪了，我一直把this.props.children当做是一个object。然后去查了下官方文档，找到了相关的介绍，于是大概翻译过来。
一般来说this.props.children会是以下几种类型
字符串这是对于特定类型的component才有效，例如Text，写法也很简单
&lt;Text&gt;i&#39;m props.c
      <a class="read-more" href="/2018/02/28/rn-props-children/"> ... </a>
    </div>
    <div class="post-item-extra">
      <div class="date">2018.02.28</div>
      <div class="tags">
        
        <div class="tag-item">ReactNative</div>
        
      </div>
    </div>
  </section>
  
  <section class="post-item">
    <a class="post-item-title" href="/2018/02/27/rn-manual-redux/">ReactNative之手动实现一个Redux</a>
    <div class="post-item-summary">
      最近我一直在考虑是否要移除项目中的redux使用，要做这个决定，首先是要搞明白redux的目的是什么，然后看看使用redux有哪些利弊。网上最适合了解redux的是redux中文文档。
假设我们只有一个界面，那肯定不需要redux了，直接对this.state操作就行了，但如果有两个界面A和B，在A界面的操作需要改变B界面，在B界面的操作需要改变A界面，那么要么它们互相暴露接口，要么让它们把state放到共同的父组件里然后通过props传递下去，这样已经很复杂了，一旦有更多页
      <a class="read-more" href="/2018/02/27/rn-manual-redux/"> ... </a>
    </div>
    <div class="post-item-extra">
      <div class="date">2018.02.27</div>
      <div class="tags">
        
        <div class="tag-item">ReactNative</div>
        
      </div>
    </div>
  </section>
  
  <section class="post-item">
    <a class="post-item-title" href="/2018/02/26/rn-android-communicate/">ReactNative之js与native通信流程（Android篇）</a>
    <div class="post-item-summary">
      这篇文章简要介绍一下android平台，js和java互相调用时，经过的流程。
js调用java要从js端调用java代码，需要把java端能被调用的接口，在js代码中进行注册。这个实现在react-native&#x2F;Libraries&#x2F;BatchedBridge&#x2F;NativeModules.js文件中。
看NativeModules.js内的代码里有：
let NativeModules : &#123;[moduleName: string]: 
      <a class="read-more" href="/2018/02/26/rn-android-communicate/"> ... </a>
    </div>
    <div class="post-item-extra">
      <div class="date">2018.02.26</div>
      <div class="tags">
        
        <div class="tag-item">ReactNative</div>
        
      </div>
    </div>
  </section>
  
</div>


<div class="paginator">
  <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
</div>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2024 typo</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>