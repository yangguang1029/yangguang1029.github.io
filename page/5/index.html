<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>杨光的笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
  
    <link rel="alternate" href="/atom.xml" title="杨光的笔记" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">杨光的笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa en-home"></i> Start</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa en-archive"></i> Archiv</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa en-user"></i> Über</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="Suche"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  <article id="post-js-mix-import" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/12/15/js-mix-import/">js之import与export复合</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2017-12-15T08:33:43.000Z" itemprop="datePublished">2017年12月15日</time>
</span>
      
      
      
<a href="/2017/12/15/js-mix-import/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Gästebuch
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在重构项目时有时会有这种需求，从一个文件内import进来然后export出去。这里总结一下一些写法，在<a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/module">ECMAScript6 入门</a>里有一段相关内容可做参考。内容很简单，基本就是语法规范而已。</p>
<p>首先是导出文件a.js</p>
<pre><code>//a.js
let a = &#123;&quot;a&quot;:1&#125;
export &#123;a&#125;
</code></pre>
<p>b.js需要导入a.js再导出，有一种比较简单的写法</p>
<pre><code>//b.js
export &#123;a&#125; from &quot;./a&quot;
</code></pre>
<p>在使用的时候</p>
<pre><code>//index.js
import &#123;a&#125; from &quot;./b&quot;
</code></pre>
<p>跟从b.js内正常export出来的一样对待。</p>
<p>还有一种写法效果一样，但有一点区别。就是</p>
<pre><code>//b.js
import &#123;a&#125; from &quot;./a&quot;
export &#123;a&#125;
</code></pre>
<p>这种写法的作用是<strong>在b.js内可以使用变量a</strong>，而前一种写法不能。</p>
<p>如果a.js导出的比较多，一般会使用import * 来引用，也可以使用export * 来导出，例如</p>
<pre><code>//b.js
export * from &#39;./a&#39;
export let b = &#123;&quot;b&quot;:2&#125;
//index.js
import * as B from &quot;./b&quot;
console.log(B.a); 
</code></pre>
<p>然后看一下export default的情况</p>
<pre><code>//a.js
export default a = &#123;&quot;a&quot;:1&#125;
//b.js
export a from &quot;./a&quot;					//（1）

export &#123;default as a&#125; from &quot;./a&quot;	//(2)

import a from &quot;./a&quot;					//(3)
export &#123;a&#125;
//index.js
import &#123;a&#125; from &quot;./b&quot;
</code></pre>
<p>第一种写法是错误的，第二种和第三种写法没问题，而且这两种写法在b.js内都可以正常使用变量a</p>
<p>也可以把一个普通的export转换为export default，例如</p>
<pre><code>//b.js
export &#123;a1 as default&#125; from &quot;./a&quot;
//index.js
import a1 from &quot;./b&quot;
</code></pre>
<p>但这种方法在b.js内不能使用变量名a1，如果要使用的话，下面这样写就可以了</p>
<pre><code>//b.js
import &#123;a1&#125; from &quot;./a&quot;
export default a1
</code></pre>

        
        
          <blockquote id="copyright">
              <p>Ursprünglicher Link: <a href="http://yangguang1029.github.io/page/5/index.html">http://yangguang1029.github.io/page/5/index.html</a></p>
              <p>Copyright-Erklärung: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

          
    <div class="social-share">
      <span>Aktie:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-other-programmer-ability" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/12/07/other-programmer-ability/">关于程序员工作能力的思考</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2017-12-07T07:50:39.000Z" itemprop="datePublished">2017年12月07日</time>
</span>
      
      
      
<a href="/2017/12/07/other-programmer-ability/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Gästebuch
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这个题目看起来就有点不着边，所以就当随便说说吧。昨天下午接到阿里游戏hr的电话问有没兴趣考虑亚博科技的cocos开发职位，我觉得可以了解下，于是对方说后期会有技术人员来电话沟通，挂了电话后，想想有大半年没有再接触cocos了，如果直接进行电话技术面，问起一些技术细节，我多半都不记得了，如果以此判定我技术不过关，我肯定是不承认的，但如果站在对方的角度想，你要求担任项目技术负责人的职位，却说不出个所以然来，对方又如何知道你的深浅呢。</p>
<p>程序员的面试一直是个很纠结的问题，网上相关的争论很多，追根到底就是如何判断一个程序员的工作能力。</p>
<p>先拿我自己的实际情况来说好了，我今年三月底到新的公司，工作是参与一个使用ReactNative进行app应用的开发，在此之前我从来没接触过RN，如果我直接冲着这个职位进来面试，那应该根本没有任何通过的希望，我本来面试的职位是cocos前端开发，阴错阳差给了我这个RN开发的职位。入职之后，首先因为我对NDK编译，C++,Java,JavaScript语言都比较熟，于是负责了一些原生语言和C++和JS之间API的设计实现。之后我独立负责完成了RN项目的Bundle拆分工作，这个工作需要对RN的源代码有一定的了解，我边看边学边实践，大概一个月的时间把现有的项目完成了bundle拆分。在入职后不久，看了下项目代码，因为原来的开发人员基本是原生开发人员转过来的，他们的JS代码和项目结构不是很规范，尤其是没有理解RN和web前端的数据流渲染方式的思想，所以提出了不少改进意见（大多数并没有落实下来，毕竟项目有点庞大，又有新的开发需求）。这是我这几个月做的事情，要说有多牛逼倒也不至于，但也不简单轻松，至少不谦虚的说我相信我是比身边的同事们都强一些，这也有工作业绩做证明，平时比较棘手的问题，需要跟踪深查出原因，或者可能修改源码，一般也交给我来解决。 </p>
<p>一个程序员的工作能力，在工作一段时间后，大家有目共睹了，也就不需要再证明了。然而在面试时，要怎么表现出来就是个问题了。今年年初我打算换工作时，也面试过几次，感觉其实都不太好。有一次是跟一个科大师兄一起吃饭，看能不能进入他们的U3D游戏开发项目组，同桌的还有他带来的几个技术leader，实际上也是一次面试，但我为了避免自己紧张，就当作一个普通的聊天，然后就没有然后了，我后来想想，也许是他们觉得我说的话都太空了吧，比如因为我这几年一直做cocos，没有U3D的开发经验，我就说新技术的学习其实是很简单的事，我现在也会这么说，因为我就是这么认为的。我从没接触过RN，但这几个月后，我敢说对RN的理解比很多人都强。如果说RN比较简单的话，那Unity,UE这些引擎又能多复杂吗？不过是工具而已，真正难的应该是计算机图形学吧，但实际项目中未必用到这么高深，技术能力深入到这么底层的专家也不多。</p>
<p>我觉得程序员的能力之一就是项目的代码结构设计，基本上每个程序员都知道MVC，即使是刚毕业的应届生，也能说得头头是道，但去看一个个实际项目就发现惨不忍睹了，UI和数据和逻辑代码全都混杂在一起，有人说这是很多现实原因造成的，比如项目进度比较赶啊，比如一份代码多人维护之类的，但我觉得其实是态度问题，一个认真的程序员，在动手写代码之前，要进行足够的思考，来找出最好的方案，不能只是为了把功能实现就行了。一般来说工作了三五年的程序员，如果还掌握不了一个项目的结构设计的话，那肯定是不够认真，没有经过思考。而这些不太好说清楚的东西，其实才是程序员最有价值的能力。</p>
<p>除此之外，我认为程序员最重要的能力就是解决问题的能力。碰到一个问题，通过观察思考定位到原因，然后从根本上解决，是一个好的程序员应有的能力。有的程序员在碰到问题的时候，不去想办法定位原因，很多时候靠猜测和尝试，看看这样改行不行，那样改行不行，这样的话即使问题可能解决了，但自己都不知道怎么解决的，以后碰到同样的或者类似的问题，解决起来还是很费力。还有的程序员在解决问题的时候很肤浅，比如一个component位置不对，不管是什么原因就直接改它坐标好了，结果改完在一些情况下还是不对，一个问题反反复复的折腾，可能最后还是没能彻底解决。这两种人其实都是在现实中很容易看到的。</p>
<p>上面两个是暂时能想到的，当然还会有别的方面，但说起来是一件事情，归根到底就是<strong>认真</strong>两个字。一个有技术追求的程序员，一定会想尽一切办法提高自己，努力思考，勤总结。要成为顶尖top 1%的明星程序员很难，但要成为在周围环境中突出的优秀程序员却不难，只要有认真的态度。我的这些看法在跟科大师兄聊的那次也说过，结果也显而易见，虽然我不知道他是否认同，但至少没能让他决定让我进入项目组，所以面试的时候我想也没必要说这些，还是多聊项目和技术细节好了，提前准备一下。</p>
<p>说了这么多，都是想到哪说到哪，就当是一次聊天来看吧。</p>

        
        
          <blockquote id="copyright">
              <p>Ursprünglicher Link: <a href="http://yangguang1029.github.io/page/5/index.html">http://yangguang1029.github.io/page/5/index.html</a></p>
              <p>Copyright-Erklärung: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B6%E5%AE%83/" rel="tag">其它</a></li></ul>

          
    <div class="social-share">
      <span>Aktie:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-rn-setstate-async" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/12/06/rn-setstate-async/">ReactNative之setState的同异步</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2017-12-06T12:18:36.000Z" itemprop="datePublished">2017年12月06日</time>
</span>
      
      
      
<a href="/2017/12/06/rn-setstate-async/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Gästebuch
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在<a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#setstate">官方文档</a>中关于setState有一段说明</p>
<blockquote>
<p>Think of setState() as a request rather than an immediate command to update the component. For better perceived performance, React may delay it, and then update several components in a single pass. React does not guarantee that the state changes are applied immediately.</p>
<p>setState() does not always immediately update the component. It may batch or defer the update until later. This makes reading this.state right after calling setState() a potential pitfall. Instead, use componentDidUpdate or a setState callback (setState(updater, callback)), either of which are guaranteed to fire after the update has been applied. </p>
</blockquote>
<p>可以明确地看到，setState只是发起一个请求，要求改变state，并<strong>不一定</strong>会立即执行。如果在setState后立即获取state，<strong>有可能</strong>得到的还是赋值前的旧值。这里需要特别注意的是“不一定”和“有可能”，也就意味着有的情况下是异步执行的，有的情况下是同步。我们需要搞明白分别什么情况下会是同异步。看下面的例子</p>
<pre><code>constructor(props)&#123;
    super(props);
    this.state=&#123;
        text:&quot;123&quot;
    &#125;
&#125;

componentWillUpdate()&#123;
    console.log(&quot;guangy componentWillUpdate&quot;)
&#125;

_onClick()&#123;
    console.log(&quot;guangy before set state,now value &quot; + this.state.text);
    let num = Math.floor(Math.random()*100);
    this.setState(&#123;text: &quot;&quot;+num &#125;);
    console.log(&quot;guangy after set state,now value &quot; + this.state.text);
&#125;

render()&#123;
    console.log(&quot;guangy render.....&quot;)
    return(&lt;View&gt;
        &lt;Text&gt;&#123;this.state.text&#125;&lt;/Text&gt;
        &lt;Button title=&quot;A&quot; onPress=&#123;
            ()=&gt;&#123;
                this._onClick();
            &#125;
        &#125;/&gt;
        &lt;Button title=&quot;B&quot; onPress=&#123;
            ()=&gt;&#123;
                   setTimeout(()=&gt;&#123;
                    this._onClick();
                   &#125;, 10);
            &#125;
        &#125;/&gt;
    &lt;/View&gt;);
&#125;
</code></pre>
<p>当点击A按钮时，输出log为</p>
<pre><code>guangy before set state,now value 123
guangy after set state,now value 123
guangy componentWillUpdate
guangy render.....
</code></pre>
<p>可以看到这里setState是异步执行了。</p>
<p>当点击B按钮时，输出log为</p>
<pre><code>guangy before set state,now value 123
guangy componentWillUpdate
guangy render.....
guangy after set state,now value 80
</code></pre>
<p>很明显，这里setState是同步执行了。</p>
<p>除了setTimeout外，在DeviceEventEmitter的回调函数里，也是同步执行。这跟js的事件循环机制有关，render函数,setTimeout和DeviceEventEmitter的回调都是在事件循环结束时调用，所以此时调用setState触发render会是同步的，其余时候调用setState则是异步的。</p>
<p>在setState为异步时，要注意如果在一次事件循环中多次setState，后面的会覆盖掉前面的，因为这一次循环里所有的setState会集中到一次来处理。 然后就是注意不要在setState后立即获取state，如果想要获取新的state，应该在setState传入回调函数作为第二个参数，在这个回调函数里获取。</p>
<p>setState还有一种形式就是接受function作为第一个参数，形式为</p>
<pre><code>this.setState((prevState, props)=&gt;&#123;
    return &#123;xxx&#125;;
&#125;)
</code></pre>
<p>这样可以明确知道当前state是什么状态，然后返回新的state。</p>

        
        
          <blockquote id="copyright">
              <p>Ursprünglicher Link: <a href="http://yangguang1029.github.io/page/5/index.html">http://yangguang1029.github.io/page/5/index.html</a></p>
              <p>Copyright-Erklärung: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ReactNative/" rel="tag">ReactNative</a></li></ul>

          
    <div class="social-share">
      <span>Aktie:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-rn-high-order-component" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/12/02/rn-high-order-component/">ReactNative之封装组件</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2017-12-02T12:18:36.000Z" itemprop="datePublished">2017年12月02日</time>
</span>
      
      
      
<a href="/2017/12/02/rn-high-order-component/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Gästebuch
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在项目开发中有时候会需要封装一些自定义组件以便复用，本文稍微整理一下。</p>
<p>我们基于一个自定义组件进行封装，这样方便通过console观察函数的调用情况</p>
<pre><code>class MyComponent extends Component&#123;
    componentWillMount()&#123;
        console.log(&quot;myComponent componentWillMount....&quot;);
    &#125;
    componentDidMount()&#123;
        console.log(&quot;myComponent componentDidMount....&quot;);
    &#125;
    render()&#123;
        return (&lt;View&gt;
            &lt;Text&gt;123&lt;/Text&gt;
            &lt;Text&gt;456&lt;/Text&gt;	
        &lt;/View&gt;);
    &#125;
&#125;
</code></pre>
<p>如果基于特定某种组件封装，那实际上就是继承，在render的时候，调用父类的render()即可。例如</p>
<pre><code>class HighComponent extends MyComponent&#123;
    componentDidMount()&#123;
        super.componentDidMount();
        console.log(&quot;HighComponent componentDidMount....&quot;);
    &#125;
    render()&#123;
        return(&lt;View style=&#123;&#123;width:100,height:100,backgroundColor:"red"&#125;&#125;&gt;
            &#123;super.render()&#125;
        &lt;/View&gt;)
    &#125;
&#125;
</code></pre>
<p>这里需要注意一点的就是分清子类是否需要重写父类的方法，如果不重写，则会直接使用父类的实现，就像上面的componentWillMount函数。如果重写，判断是否需要使用super调用父类的实现，比如上面的componentDidMount函数。</p>
<p>还有一种基于特定组件封装的办法，就是重写它的render方法，例如</p>
<pre><code>import &#123;cloneElement&#125; from &quot;react&quot;
let originText = Text;
Text.prototype.render = function(...args)&#123;
    let text = originText.apply(this, args);
    return cloneElement(text, &#123;style:[
        text.props.style,
        &#123;color:&quot;red&quot;&#125;	
    ]&#125;)
&#125;
</code></pre>
<p>然后再使用Text，就发现字体颜色都变成红色了。这个cloneElement是react库里提供的一个方法，可以到源代码里查看了解如何使用</p>
<p>如果不基于特定组件，那写一个封装的函数，把需要被封装的Component传进去，例如</p>
<pre><code> function highComponent(Com)&#123;
    return (&#123;children, ...props&#125;) =&gt; &#123;
        return(&lt;View style=&#123;&#123;width:100,height:100,backgroundColor:"red"&#125;&#125;&gt;
            &lt;Com &#123;...props&#125;&gt;
                &#123;children&#125;
            &lt;/Com&gt;
        &lt;/View&gt;)
    &#125;
&#125;
const HighComponent = highComponent(MyComponent);
</code></pre>
<p>或者</p>
<pre><code>function highComponent(Com)&#123;
    class Tmp extends Component&#123;
        render()&#123;
            return(&lt;View style=&#123;&#123;width:100,height:100,backgroundColor:"red"&#125;&#125;&gt;
                &lt;Com &#123;...this.props&#125;/&gt;
            &lt;/View&gt;)
        &#125;
    &#125;
    return Tmp;
&#125;
const HighComponent = highComponent(MyComponent);
</code></pre>
<p>这个demo很简单，不论往函数里传什么Component，都会被装在一个我们自定义的View里面。</p>
<p>这两个写法效果是一样的，但后者比前者更强大一点，基于类可以实现更多功能。</p>
<h3 id="2017-12-16添加："><a href="#2017-12-16添加：" class="headerlink" title="2017&#x2F;12&#x2F;16添加："></a>2017&#x2F;12&#x2F;16添加：</h3><p>需要注意在封装组件时，如果有内部使用的style，应该使用this.props.style和内部的进行组合，否则在使用这个封装组件时传入的style就不起作用了，对于上面例子里的HighComponent，下面设置的style不会起作用。</p>
<pre><code>&lt;HighComponent style=&#123;&#123;marginLeft:50&#125;&#125; /&gt;
</code></pre>
<p>要想让传入的style生效，在封装时就要使用this.props.style</p>
<pre><code>class HighComponent extends MyComponent&#123;
    render()&#123;
        return(&lt;View style=&#123;[this.props.style, &#123;width:100,height:100,backgroundColor:&quot;red&quot;&#125;]&#125;&gt;
            &#123;super.render()&#125;
        &lt;/View&gt;)
    &#125;
&#125;
</code></pre>

        
        
          <blockquote id="copyright">
              <p>Ursprünglicher Link: <a href="http://yangguang1029.github.io/page/5/index.html">http://yangguang1029.github.io/page/5/index.html</a></p>
              <p>Copyright-Erklärung: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ReactNative/" rel="tag">ReactNative</a></li></ul>

          
    <div class="social-share">
      <span>Aktie:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-rn-listview-part-rerender" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/11/30/rn-listview-part-rerender/">ReactNative之ListView局部刷新</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2017-11-30T11:18:36.000Z" itemprop="datePublished">2017年11月30日</time>
</span>
      
      
      
<a href="/2017/11/30/rn-listview-part-rerender/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Gästebuch
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们直接来看一个很简单的demo，一个listView和一个button，点击按钮后，随机一行的数字加100。通过观察log可以看到，每次点击按钮后，_renderRow会被重新调用25次，每个MyComponent的render函数都被重新调用了一次。我们在dataSource的rowHasChanged回调里打了log，却发现没有被调用。所以虽然只改变了一行数据，却刷新了整个listView。这样肯定对性能会造成影响。这篇文章记录了修复这个bug的流程，如果不想看的话可以直接跳到最后看解决方案。demo代码如下</p>
<pre><code>class MyComponent extends Component&#123;
    render()&#123;
        console.log(&quot;guangy call render with tag &quot; + this.props.tag);
        return &lt;Text&gt;&#123;this.props.text&#125;&lt;/Text&gt;
    &#125;
&#125;
export default class TestList extends Component&#123;
    constructor(props)&#123;
        super(props);
        this.state = &#123;
            dataSource: new ListView.DataSource(&#123;
                rowHasChanged: (rowData1, rowData2) =&gt; &#123;
                    console.log(&quot;guangy rowHasChanged&quot;)
                    return rowData1 !== rowData2;
                    &#125;,
            &#125;),
            data:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26],
        &#125;
    &#125;

    _renderRow(rowData, sid, rid)&#123;
        console.log(&quot;guangy _renderRow&quot;);
        return (&lt;View style=&#123;&#123;width:360,height:40,alignItems:"center",justifyContent:"center"&#125;&#125;&gt;
            &lt;MyComponent tag=&#123;rid&#125; text=&#123;rowData&#125;/&gt;
            &lt;/View&gt;);
    &#125;

    render()&#123;
        return &lt;View&gt;&lt;ListView
            style=&#123;&#123;
                	width:360,
                	height:600
            	&#125;&#125;
            dataSource=&#123;this.state.dataSource.cloneWithRows(this.state.data)&#125;
            renderRow=&#123;this._renderRow.bind(this)&#125;
            enableEmptySections=&#123;true&#125;
        /&gt;
        &lt;Button title=&quot;click&quot; onPress=&#123;()=&gt;&#123;
            let arr = this.state.data;
            let len = arr.length;
            let index = Math.floor(Math.random() * len);
            arr[index] += 100;
            this.setState(&#123;data:arr&#125;);
        &#125;&#125;/&gt;
        &lt;/View&gt;
    &#125;
&#125;
</code></pre>
<p>既然是rowHasChanged不被调用，我们去源代码里找一下在哪里被用，然后就查到了ListViewDataSource的_calculateDirtyArrays方法，从方法名就能看出来，这是在计算哪些单元行变dirty了需要re-render。</p>
<pre><code>dirty =
      !prevSectionsHash[sectionID] ||
      !prevRowsHash[sectionID][rowID] ||
      this._rowHasChanged(
        this._getRowData(prevDataBlob, sectionID, rowID),
        this._getRowData(this._dataBlob, sectionID, rowID),
      );
</code></pre>
<p>所以一旦prevSectionsHash[sectionID]为false或者prevRowsHash[sectionID][rowID]为false，_rowHasChanged回调就没机会被调用了。通过log也可以看到_calculateDirtyArrays函数传进来的实参prevSectionIDs和prevRowIDs是[]</p>
<p>调用这个函数的地方是ListViewDataSource的cloneWithRowsAndSections方法</p>
<pre><code>newSource._calculateDirtyArrays(
  this._dataBlob,
  this.sectionIdentities,
  this.rowIdentities,
);
</code></pre>
<p>这里是创建了一个newSource,用来计算dirtyArrays的是原来的sectionIdentities和rowIdentities。看到这里就明白整个逻辑了，每次调用cloneWithRowsAndSections函数（调用cloneWithRows实质上也是一样），返回一个新的dataSource，然后计算需要re-render的单元行。</p>
<p>所以结论就是：要实现listView的局部刷新，关键是需要调用cloneWithRows或者cloneWithRowsAndSections来生成一个新的dataSource。将代码稍微改一下，测试就没问题了。</p>
<pre><code>//this.setState(&#123;data:arr&#125;);
this.setState(&#123;dataSource:this.state.dataSource.cloneWithRows(arr)&#125;);
</code></pre>
<p>然后需要注意的是rowHasChanged回调函数，这个demo里使用的数据是简单数据类型，如果是复杂数据类型，简单的使用&#x3D;&#x3D;&#x3D;就会有问题了，有可能实际数据内容没变化但引用变化了，导致不应该re-render但却触发了。或者实际数据内容变化了但是引用没变，导致应该re-render却没触发。简而言之就是复杂数据类型应该比较实际数据内容。</p>
<p>另外一个实现局部刷新的方案是将renderRow返回的Component进行封装，实现其shouldComponentUpdate接口。这个方法比较绕，所以最好还是使用ListView本身提供好的接口rowHasChanged。</p>
<p>这个例子很简单，所以一眼就能看出来问题。但如果项目使用了redux，问题就很隐蔽了。使用redux时，数据数组存储在store里，dataSource在页面里才创建，当数据发生变化时，redux触发setState修改的就是数组，而不是dataSource，导致整个listView都刷新了。这个情况下要局部刷新，首先在store里储存dataSource，reducer内数据更新时也更新dataSource，其次需要rowHasChanged函数不能简单的使用row1!&#x3D;&#x3D;row2，而是要比较实际内容，因为redux基于imutable原则，即使内容不变，row1和row2也不是同一个对象了。</p>

        
        
          <blockquote id="copyright">
              <p>Ursprünglicher Link: <a href="http://yangguang1029.github.io/page/5/index.html">http://yangguang1029.github.io/page/5/index.html</a></p>
              <p>Copyright-Erklärung: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ReactNative/" rel="tag">ReactNative</a></li></ul>

          
    <div class="social-share">
      <span>Aktie:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-rn-overlap-touch" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/11/15/rn-overlap-touch/">ReactNative之重叠区域触摸处理</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2017-11-15T11:18:36.000Z" itemprop="datePublished">2017年11月15日</time>
</span>
      
      
      
<a href="/2017/11/15/rn-overlap-touch/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Gästebuch
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在做界面时，写了一个弹窗界面，它有个全屏的半透明背景，只是一个普通的View，当弹窗弹出时，发现原来界面的所有触摸都失效了，就像这个半透明背景把触摸都吃掉了一样，按照原来用cocos的习惯，一个普通的View如果不去指定接受触摸，应该不会处理触摸，而是将触摸传递给下一层界面才对。</p>
<p>为了确定RN的触摸传递机制，写了个demo试验了一下。就不贴代码了，很简单，界面上写两个View分别是A和B，他们区域重叠且A被B覆盖，给他们都设定onStartShouldSetResponder接口，只有这个接口返回true，才会感受到触摸。可以观察到，无论B的onStartShouldSetResponder返回true还是false,当触摸发生在重叠区域时，A的onStartShouldSetResponder都不会被回调。这样结论就很明显了，<strong>同级组件如果有重叠区域，则重叠区域内触摸事件完全由后渲染组件接受，先渲染组件连是否接受触摸的回调都不会被调用，不可能有机会处理触摸</strong></p>
<p>然后是父子节点，触摸父子节点的重叠区域，子节点的onStartShouldSetResponder会先被调用，如果子节点的onStartShouldSetResponder返回了true，那么父节点的onStartShouldSetResponder将不再被调用，也就是父节点没有机会响应触摸，如果子节点的onStartShouldSetResponder返回了false，那么父节点的onStartShouldSetResponder会被调用，此时子节点忽略触摸，交由父节点处理。</p>
<p>如果区域不重叠，那显然各干各的，如果重叠，则是遵循上面的原则。所以再看最开始那个例子，这个弹窗有个全屏背景，即使只是一个普通View，没有写任何触摸相关的代码，他也会把同级节点的触摸事件全部屏蔽了。如果一定要让触摸传递下去，可能只能想办法hack了，比如修改层级关系。</p>

        
        
          <blockquote id="copyright">
              <p>Ursprünglicher Link: <a href="http://yangguang1029.github.io/page/5/index.html">http://yangguang1029.github.io/page/5/index.html</a></p>
              <p>Copyright-Erklärung: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ReactNative/" rel="tag">ReactNative</a></li></ul>

          
    <div class="social-share">
      <span>Aktie:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-es6-circle-import" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/11/13/es6-circle-import/">ES6中循环引用的坑</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2017-11-13T12:08:14.000Z" itemprop="datePublished">2017年11月13日</time>
</span>
      
      
      
<a href="/2017/11/13/es6-circle-import/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Gästebuch
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天碰到一个很诡异的问题，在import一个模块后直接使用，结果就报红屏错误 undefined is not a function，当时很奇怪，明明那个模块export了很多东西，而且别的地方import又是正常的，为什么在这里import就出问题呢？用console打印出来，发现import进来的结果是个{}。代码大概就是</p>
<pre><code>import Test from &quot;./test&quot;
Test.test();	//这里报错，说test是个undefined，所以不能当做方法调用
</code></pre>
<p>后来突然想到，可能是产生循环引用了，一查果然是这个原因。因为项目比较庞大，不小心还是很容易间接产生循环import。</p>
<p>查阅<a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/module-loader">阮老师的ES6教程</a>里有ES6关于循环import的说明。写一个简单的例子</p>
<pre><code>//a.js
console.log(&quot;before import b&quot;)
import &#123;b&#125; from &quot;./b&quot;
console.log(&quot;b is &quot; + b)
export let a = b+1;

//b.js
console.log(&quot;before import a&quot;)
import &#123;a&#125; from &quot;./a&quot;
console.log(&quot;a is &quot; + a)
export let b = a+1;
</code></pre>
<p>结果是</p>
<pre><code>before import a
a is undefined
before import b
b is NAN
</code></pre>
<p>这里有一个有趣的现象就是第一句输出并不是before import b，也就是虽然import语句在后面，但确会更早执行，当执行import b时，加载并运行b.js，从而第一句输出是before import a。</p>
<p>然后就是当运行b.js时，发现又需要import a.js，此时不会再去加载a.js了，而是认为整个a.js模块是{}，所以a的值就是undefined了。可以通过以下代码验证</p>
<pre><code>//b.js
import * as A from &quot;./a&quot;
console.dir(A)	//输出为&#123;&#125;
</code></pre>
<p>因为循环import一旦出现查找起来比较麻烦，经过了好多个中转，每个文件又都import了很多，很难找到是怎么导致循环的。一个避免出问题的方法就是少写立即执行的代码，尽量使用函数封装起来，需要的时候调用函数，就不会出错了。</p>
<p>对于像constants, enum, global等一些需要立即执行的模块，则手动确保不要产生循环即可。</p>

        
        
          <blockquote id="copyright">
              <p>Ursprünglicher Link: <a href="http://yangguang1029.github.io/page/5/index.html">http://yangguang1029.github.io/page/5/index.html</a></p>
              <p>Copyright-Erklärung: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

          
    <div class="social-share">
      <span>Aktie:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-rn-cli-add-params" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/11/06/rn-cli-add-params/">ReactNative之给bundle命令增加参数</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2017-11-06T12:18:36.000Z" itemprop="datePublished">2017年11月06日</time>
</span>
      
      
      
<a href="/2017/11/06/rn-cli-add-params/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Gästebuch
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>因为拆分bundle的需要，在使用react-native bundle命令打业务bundle时，需要不同bundle的module id不一样，如果直接打，它们的id都是从0开始递增的。为了解决这个问题，通过修改源代码，给react-native bundle命令增加了两个参数，指定打bundle时生成ModuleID的行为。</p>
<p>首先我们跟踪下react-native bundle命令运行的轨迹</p>
<p>cli功能的源代码位于node_modules&#x2F;react-native&#x2F;local-cli文件夹内，cliEntry.js的111行</p>
<pre><code>return command.func(argv, config, passedOptions);
</code></pre>
<p>是执行命令行的入口，react-native bundle命令就是从这里进入了local-cli&#x2F;bundle&#x2F;bundle.js内的bundle方法，然后进入buildBundle.js内的buildBundle方法。</p>
<p>之后是node_modules&#x2F;react-native&#x2F;packager&#x2F;react-packager&#x2F;src&#x2F;Server&#x2F;index.js。从它的buildBundle方法，可以再跟踪到packager&#x2F;react-packager&#x2F;src&#x2F;Bundler文件夹，这里的index.js内有一个方法createModuleIdFactory就是给每个模块生成一个module id的地方，我们把这个函数改一下就可以了。</p>
<p>因为参数传递比较复杂，我采用了一种比较很简单而且不会修改太多源代码的方法，就是在local-cli&#x2F;bundle&#x2F;bundle.js的bundle方法内读取我们增加的参数，存成全局变量，在需要用的地方读取即可。</p>
<pre><code>function bundle(argv, config, args, packagerInstance) &#123;
      let cid = args.cid;	//modified by guangy cid为common module的最大数字 add为需要加的数字
      let add = args.add;
      setCidAndAdd(cid, add);

      return bundleWithOutput(argv, config, args, undefined, packagerInstance);
&#125;
</code></pre>
<p>存储和读取cid和add参数的代码为</p>
<pre><code>let cid = 10000;
let add = 0;

export function setCidAndAdd(_cid, _add) &#123;
    cid = parseInt(_cid);
    add = parseInt(_add);
&#125;

export function getCidAndAdd()&#123;
    return &#123;cid, add&#125;
&#125;
</code></pre>
<p>最后在createModuleIdFactory方法里，通过调用getCidAndAdd获取cid和add的值来使用就可以了。</p>
<p>可以看到cli功能是用nodejs实现的，对于react-native bundle命令，从命令行读取什么参数，是否必带，是否有默认值等等在local-cli&#x2F;bundle&#x2F;bundleCommandLineArgs.js里进行配置，我们这次需要增加两个参数，只需要照已有的增加就行了。command里使用&lt;&gt;表示强制要求必须带这个参数。</p>
<pre><code>&#123; //modified by guangy 增加两个参数 add和cid
command: &#39;--cid &lt;cid&gt;&#39;,
description: &#39;common的最大Module id
  &#125;,&#123;
command: &#39;--add &lt;add&gt;&#39;,
description: &#39;需要加的数字，比如10000，20000&#39;,
  &#125;,
</code></pre>
<p>然后还需要修改下node_modules&#x2F;react-native&#x2F;packager&#x2F;react-packager&#x2F;src&#x2F;Server&#x2F;index.js文件里的const bundleOpts &#x3D; declareOpts({…})<br>增加</p>
<pre><code>cid: &#123;  //modified by guangy 增加两个参数
    type: &#39;string&#39;,
    required: true,
  &#125;,
  add: &#123;
    type: &#39;string&#39;,
    required: true,
  &#125;,
</code></pre>
<p>即可。</p>
<p>如果要修改其他命令，也可以照着这个思路，先把流程捋顺了，不用每行代码都看明白，大概找到需要改动的地方就行了</p>

        
        
          <blockquote id="copyright">
              <p>Ursprünglicher Link: <a href="http://yangguang1029.github.io/page/5/index.html">http://yangguang1029.github.io/page/5/index.html</a></p>
              <p>Copyright-Erklärung: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ReactNative/" rel="tag">ReactNative</a></li></ul>

          
    <div class="social-share">
      <span>Aktie:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-rn-split-bundle2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/11/03/rn-split-bundle2/">ReactNative拆分bundle方案</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2017-11-03T12:15:36.000Z" itemprop="datePublished">2017年11月03日</time>
</span>
      
      
      
<a href="/2017/11/03/rn-split-bundle2/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Gästebuch
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="为什么要拆分bundle？"><a href="#为什么要拆分bundle？" class="headerlink" title="为什么要拆分bundle？"></a>为什么要拆分bundle？</h3><p>我们知道RN项目中的js代码会被打成一整个bundle来加载执行，这个Bundle包含了我们自己写的业务代码和RN源代码。如果不进行拆分，我们在做热更新时，哪怕业务代码只更改了一行，也需要更新一整个bundle，其中RN源代码至少占用500k以上，如果使用了第三方库如redux等还会更多，这是很大的浪费。其次是可能一个项目中包含多个RN业务，这样加载它们各自的bundle都带有RN源代码以及第三方库，也就意味着这些公共代码被重复加载了很多次。</p>
<h3 id="bundle内容"><a href="#bundle内容" class="headerlink" title="bundle内容"></a>bundle内容</h3><p>我们使用命令来打一个bundle进行观察，看bundle内都有什么</p>
<pre><code>react-native bundle --entry-file index.android.js --platform android --dev false --bundle-output android/app/src/main/assets --assets-dest android/app/src/main/res
</code></pre>
<p>这里我们生成的是release版本的bundle，比较容易看出来三个部分。如果需要阅读代码，则把–dev设为true生成debug版本的bundle即可</p>
<p>第一个部分在release版本的bundle内大概占11行，他们是为js解释器注入了一些关键字和功能</p>
<pre><code>global.require=_require
global.__d = define
var ErrorUtils = ...
Object.assign = ...
function guardedLoadModule(moduleId, module)&#123;	...
</code></pre>
<p>第二个部分占了整个bundle的绝大部分内容，它们都是以__d开头，我们以一个最短的举例</p>
<pre><code>__d(function(t,n,c,i)&#123;&quot;use strict&quot;;function o(t,n,c,i,o)&#123;&#125;c.exports=o&#125;,22);
</code></pre>
<p>第三个部分是模块的调用，第二个部分是进行了模块的注册，如果想要代码执行，就必须调用模块，这是bundle内的最后两行</p>
<pre><code>;require(65);
;require(0);
</code></pre>
<p>这个数字65根据不同的项目是不一样的。</p>
<h3 id="如何拆分"><a href="#如何拆分" class="headerlink" title="如何拆分"></a>如何拆分</h3><p>bundle需要被拆分为RN源代码和业务代码。我们知道js代码的入口在index.android.js(或者index.ios.js)，从这个入口文件起根据依赖关系，最后所有引用到的js文件被合并成了一整个bundle，我们给它命名total.bundle。然后我们把index.android.js里的代码注释掉，只保留对RN源代码的引用，例如</p>
<pre><code>import &quot;react&quot;
import &quot;react-native&quot;
</code></pre>
<p>当然如果我们把一些第三方库例如redux也算入RN代码的话，也可以加上。这样生成的bundle我们命名为common.bundle。</p>
<p>我们观察一下common.bundle里第二部分定义的最后一个模块数字id为多少，在total.bundle内，从这个id以后的内容我们就可以拆分出来，生成新文件business.bundle，这就是我们的业务代码了。</p>
<p>然后我们处理一下common.bundle，我们找到它第二部分里定义模块0的那行代码和最后一行也就是require(0)去掉，这是入口文件，我们common bundle只需要引擎。而且我们的业务代码中入口文件也被定义为模块0，如果有两个模块0，则在分步加载时会有问题。</p>
<p>这样我们就把原来的total.bundle拆分成了common.bundle和business.bundle，之后就是如何使用了</p>
<h3 id="合并加载"><a href="#合并加载" class="headerlink" title="合并加载"></a>合并加载</h3><p>最简单的方案就是在加载bundle的时候，将这两个bundle一起读成字符串，然后合并成一个字符串，再进行加载。</p>
<p>我们可以在node_modules&#x2F;react-native&#x2F;ReactCommon&#x2F;Instance.cpp里找到加载bundle的方法：loadScriptFromFile，在这里进行拼接即可。</p>
<p>这种方案可以减少热更新时bundle的大小，但不能优化加载bundle时的内存使用。</p>
<h3 id="分步加载"><a href="#分步加载" class="headerlink" title="分步加载"></a>分步加载</h3><p>这种方案需要对RN加载bundle的流程比较熟悉。我们在加载common.bundle时，不需要进入RN界面，也就是不需要启动一个ReactNativeActivity，而在源代码中，是在ReactNativeActivity的onCreate函数里加载js bundle并创建context的，所以我们将这些操作提出来。然后当需要加载业务代码business.bundle时，也不能简单的使用一个ReactNativeActivity，因为我们需要使用之前创建好的context，而不能重新创建。</p>
<p>具体操作是：我们使用一个Application implements ReactApplication，它会持有一个ReactNativeHost对象，这个对象host对象又会持有ReactInstanceManager对象，我们调用这个manager对象的createContextInBackground方法来加载common.bundle，创建了js context。</p>
<p>当我们需要加载business.bundle并进去RN界面时，我们使用一个普通的Activity，在它的onCreate函数里，构造一个ReactRootView,并设为contentView, 然后我们通过Application获取到host再获取到ReactInstanceManager，通过反射或者修改源代码，将manager绑定给这个ReactRootView，通过给它设置jsModuleName, 最后通过ReactInstanceManager获取CatalystInstance类，调用其loadScriptFromAssets或者loadScriptFromFile接口加载business.bundle即可。</p>
<p>这种方案将原来一整个Bundle加载分成了两步，在加载business.bundle时能够减少内存使用，提高加载性能。</p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>我在github上放了一个<a target="_blank" rel="noopener" href="https://github.com/yangguang1029/ReactNativeSplit.git">demo</a>。做到让这个demo运行的程度并不意味着就万事大吉了，多个bundle之间模块的冲突，全局变量和方法冲突，图片路径问题，sourcemap解析等还有很多需要处理的问题，我们解决了不少，且目前已经在线上使用了。欢迎讨论交流。</p>

        
        
          <blockquote id="copyright">
              <p>Ursprünglicher Link: <a href="http://yangguang1029.github.io/page/5/index.html">http://yangguang1029.github.io/page/5/index.html</a></p>
              <p>Copyright-Erklärung: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ReactNative/" rel="tag">ReactNative</a></li></ul>

          
    <div class="social-share">
      <span>Aktie:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-rn-run-release" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/11/02/rn-run-release/">ReactNative之生成android debug安装包</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2017-11-02T12:18:36.000Z" itemprop="datePublished">2017年11月02日</time>
</span>
      
      
      
<a href="/2017/11/02/rn-run-release/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  Gästebuch
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们使用react-native init创建一个空的项目，想要让它在android设备上跑起来，<a target="_blank" rel="noopener" href="https://reactnative.cn/docs/0.43/running-on-device-android.html#content">官网教程</a>给的方案就是使用react-native run-android命令开启联网调试，或者使用.&#x2F;gradlew assembleRelease来生成安装包。 前者必须依赖开发机开启联网服务，然后手机设置好服务器和端口并连接，否则要么屏幕一片空白，要么提示红屏报错。找到android&#x2F;app&#x2F;build&#x2F;output&#x2F;appDebug.apk可以看到安装包内没有Bundle等资源。后者需要配置签名。实际上如果我们想查看apk实际运行状况，可以很快生成一个debug安装包。</p>
<h3 id="打包bundle"><a href="#打包bundle" class="headerlink" title="打包bundle"></a>打包bundle</h3><p>这是最重要的一步，在项目根目录下执行</p>
<pre><code>react-native bundle --entry-file index.android.js --platform android --dev false --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res
</code></pre>
<p>这里最重要的是指定–bundle-output和–assets-dest两个参数。首先是–bundle-output，它必须放在android&#x2F;app&#x2F;src&#x2F;main&#x2F;assets目录下，如果该目录不存在就创建。必须指定文件名为index.android.bundle。 所有的图片资源必须放在android&#x2F;app&#x2F;src&#x2F;main&#x2F;res下，否则会无法找到图片资源而不能显示。</p>
<h3 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h3><p>到android目录下执行.&#x2F;gradlew installDebug即可</p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>在打包bundle那一步中，很多参数只是遵循默认的设置，比如bundle文件名叫index.android.bundle，位置在assets目录下，这些都可以按自己的需求来改，但前提是在java代码内也要做相应的调整，如果对这块不是很熟悉就按默认的来就行了。</p>
<p>不过–assets-dest目录必须在res目录下这个一定要遵守，因为Android系统要使用安装包内的资源，必须先转换成res id，如果放到别的文件夹下，没法转换，最后肯定找不到资源，也就没法显示图片了。</p>

        
        
          <blockquote id="copyright">
              <p>Ursprünglicher Link: <a href="http://yangguang1029.github.io/page/5/index.html">http://yangguang1029.github.io/page/5/index.html</a></p>
              <p>Copyright-Erklärung: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ReactNative/" rel="tag">ReactNative</a></li></ul>

          
    <div class="social-share">
      <span>Aktie:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>



    <nav id="page-nav">

<a class="extend prev" rel="prev" href="/page/4/">Vorheriger</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/6/">Nächster</a>
</nav>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> Letzte</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/24/restart/">不忘初心，重新开始</a>
          </li>
        
          <li>
            <a href="/2019/12/17/rn-new-architecture1/">ReactNative新架构简介之一（React and Codegen）</a>
          </li>
        
          <li>
            <a href="/2019/12/02/rn-improve-performance1/">ReactNative性能优化系列（一）包体积优化</a>
          </li>
        
          <li>
            <a href="/2019/10/09/rn-reconciliation-discussion/">ReactNative之一次Reconciliation讨论</a>
          </li>
        
          <li>
            <a href="/2019/10/08/rn-performance-do-and-dont/">ReactNative性能优化实践</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ObjectiveC/" style="font-size: 10px;">ObjectiveC</a> <a href="/tags/ReactNative/" style="font-size: 20px;">ReactNative</a> <a href="/tags/c/" style="font-size: 12px;">c++</a> <a href="/tags/cocos/" style="font-size: 18px;">cocos</a> <a href="/tags/git/" style="font-size: 12px;">git</a> <a href="/tags/google-closure-compiler/" style="font-size: 12px;">google-closure-compiler</a> <a href="/tags/javascript/" style="font-size: 16px;">javascript</a> <a href="/tags/leetcode/" style="font-size: 12px;">leetcode</a> <a href="/tags/ndk/" style="font-size: 10px;">ndk</a> <a href="/tags/svn/" style="font-size: 12px;">svn</a> <a href="/tags/%E5%85%B6%E5%AE%83/" style="font-size: 14px;">其它</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/">2025年</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019年</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018年</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017年</a><span class="archive-list-count">39</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016年</a><span class="archive-list-count">30</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ObjectiveC/" rel="tag">ObjectiveC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReactNative/" rel="tag">ReactNative</a><span class="tag-list-count">49</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocos/" rel="tag">cocos</a><span class="tag-list-count">22</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/google-closure-compiler/" rel="tag">google-closure-compiler</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ndk/" rel="tag">ndk</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/svn/" rel="tag">svn</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B6%E5%AE%83/" rel="tag">其它</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">Sitemap</a>
        <span> | </span><a href="/atom.xml">Abonnieren Sie diese Site</a>
        <span> | </span><a href="/about/">Kontaktieren Sie den Blogger</a>
      </p>
      
      <p>
        <span>Copyright &copy; 2025 yangguang1029.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
  </div>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>












  



</body>
</html>